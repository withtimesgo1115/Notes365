## golang 中 make 和 new 的区别？
共同点：给变量分配内存

不同点：

1. 作用变量类型不同，new给结构体，string,int和数组分配内存，make给切片，map，channel分配内存；

2. 返回类型不一样，new返回指向变量的指针，make返回变量本身；

3. new 只分配内存并将其初始化为零值。make 分配空间后，会进行初始化；

4. 分配的位置：new可能在栈上也可能在堆上，取决于编译器逃逸分析。make是在堆上。


## 数组和切片的区别 （基本必问）
2、数组和切片的区别 （基本必问）   
相同点：
1. 只能存储一组相同类型的数据结构

2. 都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取

区别：
1. 数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容  

2. 数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变

## for range 的时候它的地址会发生变化么？
在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。

## go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？
作用：defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;

避坑指南：defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露。

多个 defer 调用顺序是 LIFO（后入先出），defer后的操作可以理解为压入栈中

defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。defer可以修改函数最终返回值，修改时机：有名返回值或者函数返回指针

## 能介绍下 rune 类型吗？
在 Go 语言中，rune 是一种特殊的数据类型，它本质上是 int32 类型的别名，用于表示一个 Unicode 码点（字符）。Go 语言的 rune 类型让我们能够方便地处理 Unicode 字符，而不仅仅是 ASCII 字符。

rune 的特点：
表示 Unicode 码点：rune 类型是 Go 中对字符的抽象，它表示的是一个 Unicode 码点，即一个 Unicode 字符的编号。每个 rune 实际上是一个 32 位的整数，能够表示从 U+0000 到 U+10FFFF 范围内的所有 Unicode 字符。

别名：rune 是 Go 中 int32 类型的别名，它存在的主要目的是让代码更具可读性，表明这个整数实际上表示的是一个 Unicode 字符。

与 byte 的对比：byte 是 uint8 的别名，主要用于表示一个 ASCII 字符或者一个字节。rune 则用来表示宽字符（Unicode 字符）。byte 处理的范围在 0 到 255 之间，而 rune 则是 32 位宽，可以处理更广泛的字符集。

## golang 中解析 tag 是怎么实现的？反射原理是什么？(中高级肯定会问，比较难，需要自己多去总结)
Go 中解析的 tag 是通过反射实现的，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力或动态知道给定数据对象的类型和结构，并有机会修改它。反射将接口变量转换成反射对象 Type 和 Value；反射可以通过反射对象 Value 还原成原先的接口变量；反射可以用来修改一个变量的值，前提是这个值可以被修改；tag是啥:结构体支持标记，name string `json:name-field` 就是 `json:name-field` 这部分

gorm json yaml gRPC protobuf gin.Bind()都是通过反射来实现的

## 调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）

Go 的函数参数传递都是值传递。所谓值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数

因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。

传值适用于不需要修改原结构体，且结构体较小的场景。
传指针适用于需要修改结构体内容，或结构体较大时以提高性能。


## 讲讲 Go 的 slice 底层数据结构和一些特性？
Go 的 slice 底层数据结构是由一个 array 指针指向底层数组，len 表示切片长度，cap 表示切片容量。slice 的主要实现是扩容。对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。

对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。

## 讲讲 Go 的 select 底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）

go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。linux 的系统 IO 模型有 select，poll，epoll，go 的 select 和 linux 系统 select 非常相似。

select 结构组成主要是由 case 语句和执行的函数组成 select 实现的多路复用是：每个线程或者进程都先到注册和接受的 channel（装置）注册，然后阻塞，然后只有一个线程在运输，当注册的线程和进程准备好数据后，装置会根据注册的信息得到相应的数据。

### select 的特性

1）select 允许同时监听多个 channel，等待其中任意一个 channel 的操作（读或写）可以完成。当其中一个 channel 准备好时，对应的 case 分支将会执行。

2）select 仅支持管道，而且是单协程操作。

3）每个 case 语句仅能处理一个管道，要么读要么写。

4）阻塞特性：如果所有的 channel 都没有准备好（没有任何一个可以读或写），select 将会阻塞，直到某个 channel 准备好。

5）如果多个channel都准备好时，多个 case 语句的执行顺序是随机的。

6）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。

## 讲讲 Go 的 defer 底层数据结构和一些特性？
每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。

## 单引号，双引号，反引号的区别？
单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。

双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。

反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。


## map 使用注意的点，是否并发安全？
map的类型是map[key]，key类型的key必须是可比较的，通常情况，会选择内建的基本类型，比如整数、字符串做key的类型。如果要使用struct作为key，要保证struct对象在逻辑上是不可变的。在Go语言中，map[key]函数返回结果可以是一个值，也可以是两个值。map是无序的，如果我们想要保证遍历map时元素有序，可以使用辅助的数据结构，例如orderedmap。

1. 一定要先初始化，否则panic

2. map类型是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。

## map 循环是有序的还是无序的？
无序的, map 因扩张⽽重新哈希时，各键值项存储位置都可能会发生改变，顺序自然也没法保证了，所以官方避免大家依赖顺序，直接打乱处理。就是 for range map 在开始处理循环逻辑的时候，就做了随机播种

## map 中删除一个 key，它的内存会释放么？
键值对的内存：当你使用 delete 删除一个键时，Go 的垃圾回收器会标记这个键值对为不可达对象。这些对象会在垃圾回收的下一次周期中被回收。如果没有其他引用指向该键或值所占用的内存，它们将被 GC 释放。

map 的内部结构：map 的内部结构是动态调整的，即使删除了某些键，map 可能不会立即缩减内存分配的大小（特别是当 map 仍然存储大量数据时）。因此，map 的容量在删除一些键后可能不会立即减少，但不再使用的键值对内存仍然可以被 GC 释放。

当你删除 map 中的键时，相关的键值对会被移除，内存可以被垃圾回收。
内存的回收是由 Go 的垃圾回收器控制的，不是立即发生的。
删除键后，map 的容量不会立即减少，除非重新创建并复制数据。


## 怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？
- 内置sync.Map
Go 标准库提供了 sync.Map，它是一个线程安全的 map，专门设计用于并发场景。sync.Map 使用了分段锁技术，能够高效地处理大量并发读写操作。与普通 map 不同，sync.Map 提供了原子操作（如 Load、Store、Delete 和 Range）   
优点：  
无需手动加锁，简化了代码。
为高并发场景优化，适用于频繁读写的场景。
提供了方便的原子操作。   
缺点：  
性能在某些情况下（如小规模数据）可能不如手动加锁的 map，因为 sync.Map 使用了更复杂的内部机制。
只适合某些特定场景，特别是高并发读写的情况。如果你的应用场景是读多写少，sync.Map 可能并不是最佳选择。
不支持直接的键值访问操作，不能像普通 map 那样使用索引操作符 []，而是要通过方法如 Load、Store 来操作。

- 使用读写锁  
sync.RWMutex 是读写锁，允许多个 goroutine 同时进行读操作，但写操作会独占锁。在读多写少的场景下，RWMutex 比 Mutex 更高效，因为多个读操作可以同时进行，不会互相阻塞。  
优点：  
在读多写少的场景下有更好的性能，多个读操作不会互相阻塞。   
缺点：   
比 Mutex 更复杂，如果使用不当，可能会导致死锁或性能问题。
写操作仍然会阻塞其他的读写操作。


- 使用sync.Mutex 锁   
优点：
简单易用，可以严格控制对 map 的访问。   
缺点：
无论是读操作还是写操作，都会加锁，导致并发读时的性能可能较差，因为即使是读操作，也会阻塞其他 goroutine 进行访问。

总结
sync.Mutex：适用于较小规模的并发场景，尤其是当读写操作频率差不多时。所有的操作都需要加锁，所以性能可能不是最优，但实现相对简单。

sync.RWMutex：适用于读多写少的场景，读操作不会阻塞其他的读操作，但写操作仍会阻塞所有的读写操作。如果有很多读操作，这是一个更好的选择。

sync.Map：Go 标准库中专为高并发场景设计的 map，避免了手动加锁，且为高并发场景做了优化。如果是高频率的并发读写操作，sync.Map 是不错的选择。不过，由于其内部机制比较复杂，在某些情况下性能可能不如简单的 sync.RWMutex 或 sync.Mutex。

##  nil map 和空 map 有何不同？
定义：一个 nil map 是一个没有分配内存的 map，默认情况下，一个未初始化的 map 变量就是 nil。

特点：

没有分配底层哈希表的内存。
你可以对 nil map 执行读取操作（查找键），但不能执行写入操作（插入键值对），否则会导致运行时错误（panic）。


空 map
定义：空 map 是一个已经初始化但不包含任何键值对的 map。你可以使用 make 函数来创建一个空的 map。

特点：

底层已经分配了内存（一个空的哈希表）。
你可以对空 map 进行读写操作，不会引发 panic。

## map 的数据结构是什么？是怎么实现扩容？
哈希表：核心数据结构，使用哈希算法将键映射到表中的位置。哈希表是一个数组，每个数组元素称为一个“桶”（bucket）。

桶：每个桶可以存储一个或多个键值对。当多个键哈希到同一个桶时，会发生哈希冲突。Go 使用链式法（linked list）或其他结构（如红黑树）来解决冲突。

长度和容量：map 的长度表示当前存储的键值对数量，而容量表示当前分配的桶的数量。

哈希函数：用于将键转换为哈希值。Go 使用不同的哈希函数来处理不同类型的键，以确保哈希分布尽可能均匀。

### 扩容机制
当 map 的负载因子（load factor，表示存储的元素数量与桶的数量之比）超过某个阈值时，Go 会对 map 进行扩容。扩容的过程如下：

创建新桶数组：当需要扩容时，Go 会创建一个新的、容量更大的桶数组。新的容量通常是当前容量的两倍。

重新哈希：由于扩容后桶的数量发生变化，原有的键值对需要重新计算哈希值并重新分配到新的桶中。这个过程被称为“重新哈希”（rehashing）。

迁移元素：Go 会将原有 map 中的所有键值对重新迁移到新的桶数组中。

替换旧桶：扩容完成后，旧的桶数组将被垃圾回收，新的桶数组成为 map 的新存储结构。

## slices能作为map类型的key吗？
答案是：在golang规范中，可比较的类型都可以作为map key；   
不能作为map key 的类型包括：
- slices
- maps
- functions

## context 结构是什么样的？context 使用场景和用途？
它主要用于处理请求的上下文信息，尤其是在处理并发操作时。context 类型定义在 context 包中，并通过 Context 接口来提供。

context 包提供了几种实现 Context 接口的结构体，主要包括：

background 和 todo：这两个是根上下文，通常在程序开始时创建，并用于没有其他上下文可用的情况。

context.Background()：返回一个空的上下文，通常用于主程序或初始化阶段。
context.TODO()：也是一个空的上下文，表示尚未确定的上下文，适用于尚不确定上下文使用场合的情况。
cancel：通过 context.WithCancel 创建的上下文，用于支持手动取消的操作。

timeout：通过 context.WithTimeout 创建的上下文，它会在指定的时间后自动取消。

deadline：通过 context.WithDeadline 创建的上下文，它会在指定的时间点后自动取消。

value：通过 context.WithValue 创建的上下文，用于传递请求范围内的数据。

### 使用场景和用途
context 主要用于以下场景：

请求处理：在 web 应用程序中，使用 context 传递请求的上下文信息，例如请求的取消、超时等。可以在处理请求的每个 goroutine 中使用相同的 context，以便在请求取消时可以同时取消所有相关操作。

并发控制：在多 goroutine 的场景中，可以使用 context 来控制 goroutine 的生命周期，支持取消操作。例如，在处理多个并发的 I/O 操作时，可以使用 context 来取消所有操作。

传递数据：通过 context 可以传递请求范围内的值，比如用户认证信息、请求 ID 等，而不需要通过函数参数显式传递。

小结：

1. context包通过构建树形关系的context，来达到上一层goroutine对下一层goroutine的控制。对于处理一个request请求操作，需要通过goroutine来层层控制goroutine，以及传递一些变量来共享。

2. context变量的请求周期一般为一个请求的处理周期。即针对一个请求创建context对象；在请求处理结束后，撤销此ctx变量，释放资源。

3. 每创建一个goroutine，要不将原有context传递给子goroutine，要么创建一个子context传递给goroutine.

4. Context能灵活地存储不同类型、不同数目的值，并且使多个Goroutine安全地读写其中的值。

5. 当通过父 Context对象创建子Context时，可以同时获得子Context的撤销函数，这样父goroutine就获得了子goroutine的撤销权。


原则：

1. 不要把context放到一个结构体中，应该作为第一个参数显式地传入函数

2. 即使方法允许，也不要传入一个nil的context，如果不确定需要什么context的时候，传入一个context.TODO

3. 使用context的Value相关方法应该传递和请求相关的元数据，不要用它来传递一些可选参数

4. 同样的context可以传递到多个goroutine中，Context在多个goroutine中是安全的

5. 在子context传入goroutine中后，应该在子goroutine中对该子context的Done channel进行监控，一旦该channel被关闭，应立即终止对当前请求的处理，并释放资源。

## channel 是否线程安全？锁用在什么地方？
在 Go 中，channel 是线程安全的，即可以在多个 goroutine 之间安全地传递数据。Channel 的设计初衷就是为了解决并发编程中的数据共享问题，所以其内部已经实现了同步机制，保证了并发环境下的安全性。

锁的使用：在以下情况下你可能仍然需要锁：
当需要对共享的复杂数据结构（如 map、slice）进行读写时。   
当操作共享资源的读写性能需要优化时，可以使用 sync.RWMutex。   
在使用 channel 无法高效解决的并发控制场景下，锁依然是有效的手段。   

## go channel 的底层实现原理
Go 的 channel 是基于 循环队列 和 锁 实现的。在底层，channel 的数据结构是一个 hchan 结构体，定义在 Go 的运行时包中（runtime/chan.go）。hchan 结构体的主要字段包括：
```go
// hchan is the channel structure in Go runtime.
type hchan struct {
    qcount   uint           // 队列中当前存储的元素数量
    dataqsiz uint           // 环形队列的大小（即缓冲区大小）
    buf      unsafe.Pointer // 指向缓冲区（环形队列）
    elemsize uint16         // 每个元素的大小
    closed   uint32         // 标志 channel 是否已关闭

    sendx    uint   // 下一个发送位置（缓冲区的索引）
    recvx    uint   // 下一个接收位置（缓冲区的索引）
    recvq    waitq  // 等待接收的 goroutine 队列
    sendq    waitq  // 等待发送的 goroutine 队列

    lock mutex // 互斥锁，用于保护对 channel 的并发访问
}
```

1. 无缓冲的 channel
无缓冲的 channel 在发送和接收操作之间进行同步传递，也就是说，发送方会阻塞直到有接收方接收数据，接收方会阻塞直到有发送方发送数据。

无缓冲 channel 的操作流程如下：

发送数据：

如果有 goroutine 在等待接收（recvq 队列非空），将数据直接发送给接收方，接收方解除阻塞。
如果没有接收方在等待，发送方进入阻塞状态，直到有接收方来接收数据。  

接收数据：

如果有 goroutine 在等待发送（sendq 队列非空），直接接收数据，发送方解除阻塞。
如果没有发送方，接收方进入阻塞状态，直到有数据可接收。
 
2. 带缓冲的 channel
带缓冲的 channel 类似于一个队列，它可以存储多个元素。当缓冲区未满时，发送方不会阻塞；当缓冲区未空时，接收方也不会阻塞。带缓冲的 channel 的行为更灵活：

发送数据：

如果缓冲区未满，将数据写入缓冲区。
如果缓冲区已满，发送方阻塞，直到缓冲区有空位。  

接收数据：

如果缓冲区非空，直接从缓冲区中读取数据。
如果缓冲区为空，接收方阻塞，直到有数据可读。


当 channel 满或空时，操作（发送或接收）会阻塞。这时，Go 运行时会将阻塞的 goroutine 放入 sendq 或 recvq 队列中。这些队列本质上是一个 FIFO（先进先出）队列，保证 goroutine 被按顺序唤醒。

发送阻塞：当一个 goroutine 想发送数据但没有接收者，或者缓冲区满时，它会被放入 sendq 队列中，进入阻塞状态。  
接收阻塞：当一个 goroutine 想接收数据但没有发送者，或者缓冲区为空时，它会被放入 recvq 队列中，进入阻塞状态。  
当某个 goroutine 操作使得 channel 有空间可发送或接收数据时，Go 运行时会从队列中取出一个等待中的 goroutine 并唤醒它，继续执行。

Channel 的底层：基于 hchan 结构，它包含了缓冲区、发送和接收索引、等待队列以及一个互斥锁。    
无缓冲 channel：发送和接收是同步的，发送方和接收方必须同时准备好，操作才能完成。   
带缓冲 channel：允许异步发送和接收，只要缓冲区未满，发送方不会阻塞；只要缓冲区未空，接收方不会阻塞。   
阻塞与唤醒：当 channel 满或空时，goroutine 进入等待队列，直到有新的数据可发送或接收。   
关闭 channel：关闭后接收方可以继续接收数据，发送方则会引发 panic。  

## nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？
### nil channel
```go
var ch chan int  // nil channel
```

读操作：如果对 nil channel 执行读操作（接收数据），goroutine 会永久阻塞，不会接收到任何数据。

写操作：如果对 nil channel 执行写操作（发送数据），goroutine 也会永久阻塞，不会有数据被写入。

关闭：尝试关闭一个 nil channel 会直接导致程序 panic，因为你不能关闭一个未初始化的 channel。


总结：
读、写 nil channel 会导致永久阻塞。
关闭 nil channel 会导致 panic。


### 关闭的 channel
关闭的 channel 是通过 close() 函数显式关闭的 channel，一旦关闭，该 channel 将不再允许发送数据。

```go
ch := make(chan int)
close(ch)  // 关闭 channel
```

对关闭的 channel 的操作：
读操作：对于一个已经关闭的 channel，依然可以进行读操作。

如果 channel 中还有未读取的数据，则可以继续读取这些数据。
当 channel 中的数据被读取完后，再次尝试读取数据时，将会接收到 channel 类型的 零值，且读取操作不会阻塞。
当再次读取关闭的 channel 时，只要数据已被取空，读取到的始终是零值，且不会阻塞。

写操作：对已经关闭的 channel 进行写操作会导致 panic。

再次关闭：如果尝试对已经关闭的 channel 再次调用 close()，也会导致 panic。

总结：   
读取关闭的 channel 会继续返回缓冲区中的数据，之后会返回零值且不会阻塞。
向关闭的 channel 发送数据会导致 panic。
关闭已经关闭的 channel 也会导致 panic。


### 有数据的 channel
有数据的 channel 是正在使用、且有数据存在的 channel。它可能是带缓冲的 channel，也可能是无缓冲的 channel。

读操作：对有数据的 channel 进行读取操作，会按顺序读取 channel 中的数据。如果是无缓冲 channel，接收数据会阻塞直到有发送方发送数据；如果是缓冲 channel，读取数据只要缓冲区不为空就不会阻塞。


写操作：对有数据的 channel 进行写操作，行为取决于 channel 是否为带缓冲的：

无缓冲 channel：写操作会阻塞，直到有接收方接收数据。
带缓冲 channel：只要缓冲区未满，写操作不会阻塞；当缓冲区满时，写操作会阻塞，直到有空间腾出。

关闭：你可以随时关闭一个有数据的 channel。关闭后，仍可以读取 channel 中剩余的数据，读取完后将收到零值。关闭不会丢失已发送的数据，但不能再发送新数据。

总结：
读取有数据的 channel 会返回相应的数据，直到数据耗尽后关闭返回零值。
写入有数据的缓冲 channel，若缓冲区满则会阻塞；无缓冲 channel 的写入会等待接收方。
关闭有数据的 channel 不会丢失数据，但之后不能再写入新数据。


### 总结对比
nil channel：不允许任何操作，读写会阻塞，关闭会 panic。
关闭的 channel：读取会返回零值，不再阻塞；写入和再次关闭会 panic。
有数据的 channel：根据是否带缓冲，读写会有不同的阻塞或非阻塞行为，关闭后数据不会丢失，但不能再写入。


## 讲讲 Go 的 chan 底层数据结构和主要使用场景
channel 的数据结构包含 qccount 当前队列中剩余元素个数，dataqsiz 环形队列长度，即可以存放的元素个数，buf 环形队列指针，elemsize 每个元素的大小，closed 标识关闭状态，elemtype 元素类型，sendx 队列下表，指示元素写入时存放到队列中的位置，recv 队列下表，指示元素从队列的该位置读出。recvq 等待读消息的 goroutine 队列，sendq 等待写消息的 goroutine 队列，lock 互斥锁，chan 不允许并发读写。

无缓冲和有缓冲区别： 管道没有缓冲区，从管道读数据会阻塞，直到有协程向管道中写入数据。同样，向管道写入数据也会阻塞，直到有协程从管道读取数据。管道有缓冲区但缓冲区没有数据，从管道读取数据也会阻塞，直到协程写入数据，如果管道满了，写数据也会阻塞，直到协程从缓冲区读取数据。

使用场景： 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步


## 向 channel 发送数据和从 channel 读数据的流程是什么样的？
向 channel 写数据的流程： 
- 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G,并把数据写入，最后把该 G 唤醒，结束发送过程；
- 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 
- 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒；

向 channel 读数据的流程： 
- 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 
- 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 
- 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒；


## 什么是 GMP？
1. Goroutine (G)：

    Goroutine 是 Go 语言中的用户级线程，轻量级且数量可以非常多。每一个 goroutine 代表一个可以独立执行的任务。
    Goroutine 并不会直接被操作系统内核调度，而是由 Go 运行时自行调度。
    每个 goroutine 维护一个独立的栈（初始时为 2KB，可动态增长），用于存储执行中的函数调用。

2. Processor (P)：
    Processor 是一个逻辑处理器（可理解为 CPU 核心的抽象），负责执行 goroutine，管理调度队列。每个 P 持有一个本地队列，存储它要执行的 goroutine。
    P 维护着与 goroutine 执行相关的资源，例如本地任务队列、内存分配器等。每个 P 只能绑定一个操作系统线程 M，并通过这个 M 来执行 goroutine。
    Go 语言的运行时会创建 GOMAXPROCS 个 P，默认情况下这个值与机器的 CPU 核数相等（可以通过 runtime.GOMAXPROCS() 函数设置）。

3. Machine (M)：  
    M 是一个操作系统线程（kernel thread），它真正执行 goroutine 的代码。M 负责从 P 获取要执行的 goroutine，并执行这些任务。
    M 和 P 一一绑定，但 M 是可以随时从 P 解绑的，线程在没有任务时可能会休眠。
    如果当前没有可用的 M，Go 运行时会新建一个操作系统线程（M）来执行 P 队列中的任务。


### GMP 模型的工作原理
在 Go 的 GMP 模型中，G 代表待执行的任务（goroutine），P 是 goroutine 调度的核心，M 是实际运行任务的系统线程。以下是它的运行过程：

#### 调度过程：

每个 P 会维护一个本地队列来存储 goroutine，当某个 M 绑定了 P 后，M 将从 P 的队列中取出 goroutine 执行。
P 还会从全局队列中偷取 goroutine 来均衡负载。当 P 本地任务队列为空时，它会尝试从其他 P 的队列中“偷” goroutine 执行。

#### 多线程并发：

GOMAXPROCS 控制了可以并发执行的 P 的数量。如果系统有 4 个 CPU 核心，默认情况下 Go 会创建 4 个 P，最多会有 4 个 goroutine 并发执行。
由于 P 与 M 一一绑定，因此有多少个 P，就有多少个 M 被分配执行

#### goroutine 的创建与切换：

当 Go 程序创建新的 goroutine 时，新的 G（goroutine）会被放到 P 的本地任务队列中。
如果一个 goroutine 发生了阻塞（如 I/O 或系统调用），与它关联的 M 会释放 P，从而使 P 能够被其他可用的 M 绑定，并继续执行其他任务。同时，阻塞的 M 会等待系统调用完成后重新获取一个 P 来继续执行。
当 G 需要被调度或中断时，Go 运行时会进行上下文切换，将当前 G 保存到任务队列中，并从任务队列中调度另一个 G 执行。

#### 任务窃取机制：

为了避免某些 P 上的 goroutine 堆积过多，而另一些 P 上没有任务执行，Go 运行时实现了任务窃取机制（work stealing）。当一个 P 没有任务可执行时，它会尝试从其他 P 的队列中窃取一半的任务，确保所有 P 都能均衡地处理 goroutine。


### GMP 调度的主要特点
#### 高效并发：

Go 通过 Goroutine 让开发者轻松创建大量并发任务，GMP 模型的设计使得 Go 运行时可以高效地管理和调度这些任务。
Goroutine 的调度不依赖操作系统内核调度器，而是由 Go 运行时进行用户态调度，避免了操作系统线程的频繁切换开销。

#### 自动扩展与负载均衡：

Go 运行时会根据需要动态创建或销毁 M，即操作系统线程，以处理大量的 goroutine，同时通过任务窃取机制实现负载均衡。

#### 阻塞处理：
当 M 阻塞时，不会影响 P 执行其他 goroutine，P 会解绑当前阻塞的 M 并绑定到其他可用的 M 上，保证其他 goroutine 能继续被调度执行。


## 进程、线程、协程有什么区别？
进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。

线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。

协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行

## 抢占式调度是如何抢占的？

## M 和 P 的数量问题？
p默认cpu内核数

M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来

## 除了 mutex 以外还有那些方式安全读写共享变量？
1. 将共享变量的读写放到一个 goroutine 中，其它 goroutine 通过 channel 进行读写操作。

2. 可以用个数为 1 的信号量（semaphore）实现互斥

3. 通过 Mutex 锁实现

## Go 如何实现原子操作？
原子操作就是不可中断的操作，外界是看不到原子操作的中间状态，要么看到原子操作已经完成，要么看到原子操作已经结束。在某个值的原子操作执行的过程中，CPU 绝对不会再去执行其他针对该值的操作，那么其他操作也是原子操作。

Go 语言的标准库代码包 sync/atomic 提供了原子的读取（Load 为前缀的函数）或写入（Store 为前缀的函数）某个值（这里细节还要多去查查资料）。

原子操作与互斥锁的区别

1）、互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。

2）、原子操作是针对某个值的单个互斥操作。

## Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？
悲观锁

悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制

乐观锁

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量

## Mutex 有几种模式？
正常模式和饥饿模式

正常模式是 Mutex 的默认工作模式，也是通常情况下的锁行为。在正常模式下，Go 的调度器尽量保证锁的公平性，同时优先保持高效的执行。

公平性：在正常模式下，当一个 goroutine 释放锁时，调度器会随机选择一个等待的 goroutine 来获得锁。这意味着，等待的 goroutine 不一定是按照 FIFO（先进先出）的顺序来获得锁，而是由调度器决定哪个 goroutine 先执行。这种非严格的顺序保证了锁的公平性和调度的灵活性。

性能优化：如果锁在短时间内被快速释放，Go 的调度器可能会让正在竞争的 goroutine 尝试自旋（spinning），即在锁的释放和重新获取之间尝试做一些快速循环检查，期望锁在短时间内可用，这样可以避免频繁的上下文切换，从而提高性能。

这种正常模式下，锁的获取过程更高效，但由于锁的公平性较弱，某些等待较长的 goroutine 可能会长时间得不到锁。

饥饿模式是在某些特殊情况下，Mutex 进入的一种锁竞争模式，主要用于应对锁竞争特别激烈的场景，避免长时间的“锁饥饿”现象。

触发条件：当某个 goroutine 等待锁的时间超过一定阈值（大约 1 毫秒），Mutex 就会进入饥饿模式。在饥饿模式下，锁的调度策略变为严格的 FIFO 顺序，确保等待时间最长的 goroutine 最先获得锁。

饥饿模式行为：

当锁进入饥饿模式时，当前持有锁的 goroutine 在释放锁后，不再随机选择等待的 goroutine，而是严格按照 FIFO 顺序将锁交给等待时间最长的 goroutine。
一旦处于饥饿模式的 goroutine 获得锁，它将直接持有锁，其他新来的 goroutine 将不会尝试自旋等待，而是直接加入等待队列。
只有当等待队列为空时，锁才会退出饥饿模式，回到正常模式。
饥饿模式的主要作用是确保那些长时间无法获得锁的 goroutine 最终能获得锁，防止某些 goroutine 长期处于“饥饿”状态。但饥饿模式会牺牲一定的性能，因为 FIFO 顺序限制了调度的灵活性，也可能导致频繁的上下文切换。

## goroutine 的自旋占用资源如何解决
自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。

自旋的条件如下：

1）还没自旋超过 4 次,

2）多核处理器，

3）GOMAXPROCS > 1，

4）p 上本地 goroutine 队列为空。

mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。

## 怎么控制并发数？
1. 有缓冲通道

根据通道中没有数据时读取操作陷入阻塞和通道已满时继续写入操作陷入阻塞的特性，正好实现控制并发数量。

```go
func main() {
	count := 10 // 最大支持并发
	sum := 100 // 任务总数
	wg := sync.WaitGroup{} //控制主协程等待所有子协程执行完之后再退出。

	c := make(chan struct{}, count) // 控制任务并发的chan
	defer close(c)

	for i:=0; i<sum;i++{
		wg.Add(1)
		c <- struct{}{} // 作用类似于waitgroup.Add(1)
		go func(j int) {
			defer wg.Done()
			fmt.Println(j)
			<- c // 执行完毕，释放资源
		}(i)
	}
	wg.Wait()
}
```

2. panjf2000/ants 第三方库

## 多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？
可以捕获异常，但是只能捕获一次，Go语言，可以使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover Go中，对异常处理的原则是：多用error包，少用panic

## 如何优雅的实现一个 goroutine 池

## go gc 是怎么实现的？
Go 的 GC 回收有三次演进过程，Go V1.3 之前普通标记清除（mark and sweep）方法，整体过程需要启动 STW，效率极低。GoV1.5 三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要 STW)，效率普通。GoV1.8 三色标记法，混合写屏障机制：栈空间不启动（全部标记成黑色），堆空间启用写屏障，整个过程不要 STW，效率高。

Go1.3 之前的版本所谓标记清除是先启动 STW 暂停，然后执行标记，再执行数据回收，最后停止 STW。

Go1.5 三色标记主要是插入屏障和删除屏障  

### 初始状态：
在 GC 开始时，所有对象都是白色的，表示它们尚未被标记。根对象（如全局变量和栈变量）会被初始化为灰色。

### 标记阶段：
在标记阶段，GC 会从根对象（栈、全局变量、寄存器等）开始，将所有直接可达的对象标记为灰色。
然后，GC 会处理所有灰色对象，逐个检查它们的引用。
对于每个灰色对象，GC 会将其所有引用的对象标记为灰色，并将当前对象标记为黑色。这意味着当前对象及其引用的对象都是可达的。

### 处理灰色对象：
重复这个过程，直到所有灰色对象都被处理完。处理灰色对象的过程如下：
从灰色队列中取出一个灰色对象。
将该对象标记为黑色。
遍历该对象的所有引用，将引用的对象标记为灰色（如果它们是白色的）。

### 结束标记阶段：
当灰色队列为空时，标记阶段结束。此时，所有仍然是白色的对象都被视为不可达，可以被回收。
所有黑色和灰色对象都是可达的。

### 清除阶段：
在清除之前，需要进行STW  
在标记阶段之后，GC 会进入清除阶段，回收所有白色对象的内存。此时，白色对象会被释放。  
然后解除STW。
  

Go V1.8  
1. Go 1.8 中引入了 混合写屏障（Hybrid Write Barrier），这是在原有写屏障机制基础上的改进。这一机制优化了并发标记过程中的性能。混合写屏障允许在并发标记阶段，程序可以继续执行写操作，同时确保引用更新不会干扰 GC 的准确性。
2. 减少停顿：通过减少需要等待标记完成的停顿时间，混合写屏障使得 GC 的并发性能更好，从而降低了因为 GC 而产生的长时间停顿。

正常并发标记阶段：

在标记阶段，程序继续运行，写屏障确保所有被修改的对象指针（特别是那些从灰色指向白色的对象）会正确标记。写屏障的机制通过让写入的目标对象变成“灰色”，确保回收器能够正确标记对象。

标记终止阶段（Mark Termination）：

在混合写屏障中，Go 1.8 的垃圾回收器允许标记终止阶段（也就是标记结束时的一个小的 STW 时段）更高效地完成。在标记终止阶段，混合写屏障减少了因为需要频繁暂停而引起的长时间 STW，从而大幅减少了全局停顿时间。

混合写屏障与延迟清除：

混合写屏障允许在 GC 过程中处理更加灵活，并在对象引用发生变更时直接对相关对象进行标记。这减少了需要暂停应用程序来等待标记完成的情况，同时提高了 GC 并发标记阶段的效率。




## GC 的触发时机？
分为系统触发和主动触发。  
1）gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。

2）gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟。

3）gcTriggerCycle：如果没有开启 GC，则启动 GC。

4）手动触发的 runtime.GC 方法。

## GC 中 stw 时机，各个阶段是如何解决的？
#### 标记阶段的 STW
STW 时机：在标记阶段的开始，GC 会触发 STW。这时，所有 goroutine 都会被暂停，以确保根对象（如全局变量、栈变量等）在标记开始时是稳定的，不会被并发修改。

处理方式：

GC 在标记阶段从根对象开始标记所有可达对象。此时，标记过程是安全的，因为没有 goroutine 在修改对象的状态。
一旦标记完成，GC 会更新对象的状态（如颜色），并准备进入下一个阶段。

#### 清除阶段的 STW
STW 时机：清除阶段是 GC 中最耗时的部分。GC 在清除阶段开始时需要再次触发 STW，以安全释放不可达的白色对象的内存。

处理方式：

在清除阶段，GC 遍历堆中的所有对象，查找并释放白色对象。这一过程中需要确保没有其他 goroutine 在访问或修改这些对象。
GC 完成清除后，重新启动所有 goroutine，使其恢复执行。


随着 Go 语言的发展，STW 的影响仍然是一个持续的优化方向。通过更智能的算法、更好的并发支持和持续的性能调优，未来的 Go GC 将力求进一步降低 STW 对应用程序性能的影响。



## 谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？
go 中的内存泄漏一般都是 goroutine 泄漏，就是 goroutine 没有被关闭，或者没有添加超时控制，让 goroutine 一直处于阻塞状态，不能被 GC。

内存泄露有下面一些情况

1）如果 goroutine 在执行时被阻塞而无法退出，就会导致 goroutine 的内存泄漏，一个 goroutine 的最低栈大小为 2KB，在高并发的场景下，对内存的消耗也是非常恐怖的。

2）互斥锁未释放或者造成死锁会造成内存泄漏

3）time.Ticker 是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间。

4）字符串的截取引发临时性的内存泄漏

排查方式：

一般通过 pprof 是 Go 的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是 CPU 使用情况、内存使用情况、goroutine 运行情况等，当需要性能调优或者定位 Bug 时候，这些记录的信息是相当重要。

## 知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？
1. 本该分配到栈上的变量，跑到了堆上，这就导致了内存逃逸。
2. 栈是高地址到低地址，栈上的变量，函数结束后变量会跟着回收掉，不会有额外性能的开销。
3. 变量从栈逃逸到堆上，如果要回收掉，需要进行 gc，那么 gc 一定会带来额外的性能开销。编程语言不断优化 gc 算法，主要目的都是为了减少 gc 带来的额外性能开销，变量一旦逃逸会导致性能开销变大。

内存逃逸的情况如下：

1）方法内返回局部变量指针。

2）向 channel 发送指针数据。

3）在闭包中引用包外的值。

4）在 slice 或 map 中存储指针。

5）切片（扩容后）长度太大。

6）在 interface 类型上调用方法。

## 请简述 Go 是如何分配内存的？
mcache mcentral mheap mspan

Go 程序启动的时候申请一大块内存，并且划分 spans，bitmap，areana 区域；arena 区域按照页划分成一个个小块，span 管理一个或者多个页，mcentral 管理多个 span 供现场申请使用；mcache 作为线程私有资源，来源于 mcentral。

## Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？
Channel 被设计用来实现协程间通信的组件，其作用域和生命周期不可能仅限于某个函数内部，所以 golang 直接将其分配在堆上

准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。

知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。

当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上,然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。

## 介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？
小于等于 32k 的对象就是小对象，其它都是大对象。一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。通常小对象过多会导致 GC 三色法消耗过多的 CPU。优化思路是，减少对象分配。

小对象：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 nextFree 方法获取新的可用的对象，可能会触发 GC 行为。

大对象：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为。

## Go 多返回值怎么实现的？
在底层，Go 的编译器通过元组（tuple）来处理多返回值。函数的返回值被封装在一个结构体中，调用者通过变量来获取这些值。具体步骤如下：

函数定义：在函数定义时，返回值的类型会被记录在函数的元数据中。
函数调用：当函数被调用时，调用者的栈帧中会为每个返回值分配内存。
返回值传递：函数执行结束时，返回值会被打包成一个结构体或元组，传递给调用者。调用者通过多个变量来接收这些值。

## 讲讲 Go 中主协程如何等待其余协程退出?
1. Go 的 sync.WaitGroup 是等待一组协程结束，sync.WaitGroup 只有 3 个方法，Add()是添加计数，Done()减去一个计数，Wait()阻塞直到所有的任务完成。
2. Go 里面还能通过有缓冲的 channel 实现其阻塞等待一组协程结束，这个不能保证一组 goroutine 按照顺序执行，可以并发执行协程。
3. Go 里面能通过无缓冲的 channel 实现其阻塞等待一组协程结束，这个能保证一组 goroutine 按照顺序执行，但是不能并发执行。


## Go 语言中不同的类型如何比较是否相等？
在 Go 中，以下类型是可以进行相等比较的：

基本类型：如 int、float64、string、bool 等。
结构体：结构体的所有字段都支持相等比较。
数组：数组的所有元素都支持相等比较。

切片、映射和函数：这些类型不能直接比较是否相等（即使是同类型的切片、映射或函数）。一般使用 reflect.DeepEqual 来检测是否相等。


## Go 中 init 函数的特征?
一个包下可以有多个 init 函数，每个文件也可以有多个 init 函数。多个 init 函数按照它们的文件名顺序逐个初始化。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。不管包被导入多少次，包内的 init 函数只会执行一次。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。但包级别变量的初始化先于包内 init 函数的执行。

## Go 中 uintptr 和 unsafe.Pointer 的区别？
|特性 |	uintptr	| unsafe.Pointer |
|---- |---- | ---- |
|类型 |	无符号整数|	指针类型 |
|用途	| 用于存储指针的地址和指针算术操作|	用于低级内存操作和类型转换|
| 类型安全性	|丧失类型信息	|保持类型信息|
|算术运算	|可以进行算术运算	|不能进行算术运算|
| 内存安全性	 | 需要谨慎使用，容易引发错误	| 需要谨慎使用，避免不安全操作




