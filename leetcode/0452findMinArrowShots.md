有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
示例 2：

输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。

## 思路
排序：将气球按照右边界从小到大排序。
遍历和贪心判断：我们初始化箭数量为 1，并将第一支箭的位置设为第一个气球的右边界。
更新箭的位置：如果当前气球的左边界超出了当前箭的范围，则需要增加一支新箭，并将箭的位置更新为当前气球的右边界。

这里判断是否有交叉区间, 所以其实是计算已知区间的交集数量.
这里以[[10,16],[2,8],[1,6],[7,12]] 为例子:

先排序, 我是按区间开始位置排序, 排序后: [[1,6],[2,8],[7,12],[10,16]]
遍历计算交叉区间(待发射箭头),
待发射箭头的区间range = [1, 6], 需要的箭数量 arrows = 1;
区间[2, 8], 和带发射区间[1, 6]有交集: 更新发射区域为它们的交集 range = [2, 6]
区间[7, 12], 和待发射区间[2, 6]没有任何交集, 说明需要增加一个新的发射区域, 新的待发射区域range = [7, 12]
区间[10,16], 和待发射区域[7, 12]有交集, 待发射区域更新为[10, 12]
返回需要待发射区间的个数

```py
class Solution:
    def findMinArrowShots(self, points: list[list[int]]) -> int:
        if not points:
            return 0
        points.sort(key=lambda x: x[1])
        arrows = 1
        end = points[0][1]
        for i in range(1, len(points)):
            # 完全大于，说明不包含在原来的区间，需要新的一支箭
            # 对于其他情况，其实就是贪心
            if points[i][0] > end:
                arrows += 1
                end = points[i][1]
        return arrows
```